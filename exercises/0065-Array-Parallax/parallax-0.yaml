title: "Parallax (Starter)"
descriptionMd: |
  # Parallax (Starter)

  This is the starter code for the Parallax Effect exercise. This starter code is used during interactive coding sessions. 

sampleSolution: "https://raw.githubusercontent.com/rstropek/ts-web-playground/refs/heads/main/exercises/0065-Array-Parallax/parallax-0.ts"
files:
  "index.ts":
    content: |
      const THEME_IX = 0;
      const GRAVITY = 0.8;
      const JUMP_FORCE = -15;
      const HATI = "demo_figure2.png";
      const SCROLL_SPEED = 5;

      const images: p5.Image[] = [];
      let hatiImage: p5.Image;

      let backgroundScale = 1;
      let scaledImageWidth = 0;
      let scaledImageHeight = 0;

      let scrollPosition = 0;

      let spriteDirection = 1;
      let spritePosition = 0;

      let verticalPosition = 0;
      let verticalVelocity = 0;
      let isJumping = false;

      function preload() {
          const theme = themes[THEME_IX];
          for (const imageName of theme) {
              const image = loadImage(getImageUrl(THEME_IX, imageName));
              images.push(image);
          }

          hatiImage = loadImage(getFigureUrl(HATI));
      }

      function setup() {
          createCanvas(500, 500);

          backgroundScale = width / images[0].width;
          scaledImageWidth = images[0].width * backgroundScale;
          scaledImageHeight = images[0].height * backgroundScale;

          spritePosition = width / 2;
          verticalPosition = 0;
      }

      function draw() {
          background("black");

          if (keyIsDown(39)) {
              if (spritePosition < width / 2) {
                  spritePosition += SCROLL_SPEED;
              } else if (scrollPosition > -width) {
                  scrollPosition = scrollPosition - SCROLL_SPEED;
              } else if (spritePosition < width - 30) {
                  spritePosition += SCROLL_SPEED;
              }

              spriteDirection = -1;
          } else if (keyIsDown(37)) {
              if (spritePosition > width / 2) {
                  spritePosition -= SCROLL_SPEED;
              } else if (scrollPosition < width) {
                  scrollPosition += SCROLL_SPEED;
              } else if (spritePosition > 30) {
                  spritePosition -= SCROLL_SPEED;
              }

              spriteDirection = 1;
          }

          // Uncomment the following lines to zoom out. This will make it easier for you
          // to see how the background images move out of the visible area when you press the cursor keys.
          //scale(0.5);
          //translate(width / 2, height / 2);

          push();
          translate(0, (height - scaledImageHeight) / 2);

          // This time, we do NOT translate ALL the images by the same amount (scrollPosition).
          // Instead, we move each layer by a fraction of the scrollPosition. The most distant
          // layer moves by the smallest amount (scrollPosition / images.length), the next layer
          // moves by twice that amount, and so on. The closest layer moves by the largest
          // amount.
          const step = scrollPosition / images.length;

          for (let i = 0; i < images.length; i++) {
              // Move each layer by a fraction of the scrollPosition. NOTE that we will call
              // the _translate()_ function multiple times. As you already know, calls to _translate()_
              // are cumulative. This means that the first layer will be moved by _step_, the second
              // layer will be moved by _2 * step_, the third layer will be moved by _3 * step_, and so on.
              // This will create the parallax effect.
              translate(step, 0);

              const img = images[i];

              image(img, -scaledImageWidth, 0, scaledImageWidth, scaledImageHeight);
              image(img, 0, 0, scaledImageWidth, scaledImageHeight);
              image(img, scaledImageWidth, 0, scaledImageWidth, scaledImageHeight);
          }
          pop();

          push();
          if (keyIsDown(32) && !isJumping) { // 32 is spacebar
              verticalVelocity = JUMP_FORCE;
              isJumping = true;
          }
          
          verticalVelocity += GRAVITY;
          verticalPosition += verticalVelocity;
          
          // Ground collision
          if (verticalPosition > 0) {
              verticalPosition = 0;
              verticalVelocity = 0;
              isJumping = false;
          }

          translate(spritePosition, scaledImageHeight + verticalPosition);
          scale(spriteDirection * -1, 1);
          imageMode(CENTER);
          image(hatiImage, 0, 5, hatiImage.width * backgroundScale * 0.8, hatiImage.height * backgroundScale * 0.8);
          pop();

          // Uncomment the following lines to draw a rectangle around the canvas. This will help you to see
          // how the background images move out of the visible area when you press the cursor keys. Use
          // these lines of code together with the commented _scale()_ and _translate()_ functions above.
          // push();
          // noFill();
          // stroke("red");
          // rect(0, 0, width, height);
          // pop();

          // resetMatrix();
          // push();
          // fill("white");
          // noStroke();
          // textSize(10);
          // textAlign(LEFT, TOP);
          // text(
          //     `Scroll position (x): ${scrollPosition}\n` +
          //     `Worm position (x): ${spritePosition}\n` +
          //     `Vertical position (y): ${verticalPosition.toFixed(1)}`,
          //     10, 10
          // );
          // pop();
      }

    isEditable: true
  "images.ts":
    content: |
      // URL where the images are stored. You have to append the theme name (see also _themeNames_ below)
      // and the image name to get the full URL. Example: To get the URL of the first image of the 
      // _cave_ theme, use `${BASE_URL}/cave/1_wall.png`.
      const BASE_URL = "https://cddataexchange.blob.core.windows.net/images";

      // Define the images for the different themes. The first image must be drawn first because it is the farthest away.
      // The last image must be drawn last because it is the closest to the viewer.
      const cave = [
          "1_wall.png",
          "2_prop01.png",
          "3_prop02.png",
          "4_stones.png",
          "5_crystals.png",
          "6_ground.png"
      ];
      const mountains = [
          "1_sky.png",
          "2_mountains.png",
          "3_clouds.png",
          "4_bg-ground01.png",
          "5_bg-ground02.png",
          "6_ground.png"
      ];
      const winter = [
          "1_sky.png",
          "2_stars.png",
          "3_clouds01.png",
          "4_clouds02.png",
          "5_mountains.png",
          "6_ground01.png",
          "7_ground02.png",
          "8_ground.png"
      ];
      const dessert = [
          "1_sky.png",
          "2_clouds.png",
          "3_pyramid.png",
          "4_bg-ground01.png",
          "5_bg-ground02.png",
          "6_bg-ground03.png",
          "7_ground.png"
      ];

      // _themes_ is an array of arrays. Each sub-array contains the image names for one theme.
      // If you want to get the theme _cave_, use _themes[0]_, for _winter_ use _themes[2]_, and so on.
      const themes = [
          cave,
          mountains,
          winter,
          dessert
      ];

      // The names of the themes. The order must match the order of the themes in the _themes_ array.
      const themeNames = [
          "cave",
          "mountains",
          "winter",
          "dessert"
      ]

      function getImageUrl(themeIndex: number, image: string) {
          return `${BASE_URL}/parallax/${themeNames[themeIndex]}/${image}`;
      }

      function getFigureUrl(figure: string) {
          return `${BASE_URL}/figureBuilder/${figure}`;
      }
    isEditable: false

  "index.html":
    content: |
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <script src="{{p5Source}}"></script>
          {{topScripts}}
        </head>
        <body>
          {{bodyScripts}}
        </body>
      </html>
    isEditable: false
